// Generated By AI :)

export type KeyValueConfig = Record<string, string>

function stripBom(s: string): string {
	if (s.charCodeAt(0) === 0xfeff) return s.slice(1)
	return s
}

/** Return true if the backslash at end is an unescaped line-joiner (\\ not \\\\). */
function endsWithUnescapedBackslashOutsideQuotes(line: string): boolean {
	// Track simple quote state to avoid joining when inside quotes
	let inSingle = false
	let inDouble = false

	for (let i = 0; i < line.length; i++) {
		const ch = line[i]

		if (ch === "'" && !inDouble) {
			inSingle = !inSingle
		} else if (ch === '"' && !inSingle) {
			inDouble = !inDouble
		} else if (ch === "\\" && (inSingle || inDouble)) {
			// skip next char if escaped inside quotes
			i++
		}
	}

	if (inSingle || inDouble) return false // don't treat as joiner if inside quotes

	// Count trailing backslashes
	let count = 0
	for (let i = line.length - 1; i >= 0 && line[i] === "\\"; i--) count++
	// Odd count => last backslash is unescaped
	return count % 2 === 1
}

/** Join continuation lines that end with an unescaped backslash (outside quotes). */
function joinContinuations(text: string): string[] {
	const rawLines = text.replace(/\r\n?/g, "\n").split("\n")
	const out: string[] = []
	let buffer = ""

	for (const raw of rawLines) {
		const line = buffer ? buffer + raw : raw

		if (endsWithUnescapedBackslashOutsideQuotes(line)) {
			// drop the last unescaped backslash and keep buffering
			buffer = line.slice(0, -1)
		} else {
			out.push(line)
			buffer = ""
		}
	}
	if (buffer) out.push(buffer)
	return out
}

/** Remove an inline comment that starts outside quotes (# or ;) */
function stripInlineCommentOutsideQuotes(s: string): string {
	let inSingle = false
	let inDouble = false

	for (let i = 0; i < s.length; i++) {
		const ch = s[i]

		if (ch === "'" && !inDouble) {
			inSingle = !inSingle
		} else if (ch === '"' && !inSingle) {
			inDouble = !inDouble
		} else if ((ch === "#" || ch === ";") && !inSingle && !inDouble) {
			// cut everything from here as a comment
			return s.slice(0, i).trimEnd()
		} else if (ch === "\\" && inDouble) {
			// Skip next char when escaping inside double quotes
			i++
		}
	}
	return s
}

/** Unescape sequences in a double-quoted string. Single-quoted stays literal. */
function unescapeDoubleQuoted(value: string): string {
	let out = ""
	for (let i = 0; i < value.length; i++) {
		const ch = value[i]
		if (ch === "\\") {
			const next = value[++i]
			if (next === "n") out += "\n"
			else if (next === "r") out += "\r"
			else if (next === "t") out += "\t"
			else if (next === '"') out += '"'
			else if (next === "\\") out += "\\"
			else if (next === undefined)
				out += "" // trailing backslash; drop
			else out += next // keep as-is for other sequences
		} else {
			out += ch
		}
	}
	return out
}

/** Parse a single logical line "KEY=VALUE" (after continuation-join). */
function parseLogicalLine(line: string): [key: string, value: string] | null {
	let s = line.trim()
	if (!s) return null

	// Full-line comments
	if (s.startsWith("#") || s.startsWith(";")) return null

	// Optional "export " prefix
	if (s.startsWith("export ")) s = s.slice("export ".length).trim()

	// Split on first '='
	const eqIdx = s.indexOf("=")
	if (eqIdx === -1) return null

	const rawKey = s.slice(0, eqIdx).trim()
	let rawValue = s.slice(eqIdx + 1).trim()

	if (!rawKey) return null

	// Strip inline comments outside quotes
	rawValue = stripInlineCommentOutsideQuotes(rawValue).trim()

	// Handle quoted values
	if (
		(rawValue.startsWith('"') && rawValue.endsWith('"') && rawValue.length >= 2) ||
		(rawValue.startsWith("'") && rawValue.endsWith("'") && rawValue.length >= 2)
	) {
		const quote = rawValue[0]
		let inner = rawValue.slice(1, -1)

		if (quote === '"') {
			inner = unescapeDoubleQuoted(inner)
		} // single quotes: keep literal
		return [rawKey, inner]
	}

	// Unquoted: trim only outer whitespace (already trimmed) and keep literal
	return [rawKey, rawValue]
}

export function ParseKeyValueConfig(text: string): KeyValueConfig {
	const result: KeyValueConfig = {}
	if (!text) return result

	const cleaned = stripBom(text)
	const lines = joinContinuations(cleaned)

	for (const line of lines) {
		const kv = parseLogicalLine(line)
		if (!kv) continue
		const [key, value] = kv

		// Optionally: validate key characters. We keep it permissive.
		// If you want stricter keys: /^[A-Za-z_][A-Za-z0-9_\.:-]*$/.test(key)

		// Duplicate handling: last one wins (common in env files)
		result[key] = value

		// If you prefer to keep arrays of duplicates, replace with:
		// if (key in result) {
		//   const prev = result[key];
		//   (result as any)[key] = Array.isArray(prev) ? [...prev, value] : [prev, value];
		// } else {
		//   result[key] = value;
		// }
	}

	return result
}
